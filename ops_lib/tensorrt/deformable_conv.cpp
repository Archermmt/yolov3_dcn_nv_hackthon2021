//
// Auto Generated by DLRouter on 2021-03-10 07:08:43.417297
// 

#include "trt_utils.h"
#include "deformable_conv.h"
#include "kernel/gpu/conv_kernel.h"

#include <cassert>

using namespace nvinfer1;

namespace quake {
namespace framework {
namespace ops_lib {

namespace {
  static const char* DEFORMABLE_CONV_DMC_PLUGIN_VERSION{"1"};
  static const char* DEFORMABLE_CONV_DMC_PLUGIN_NAME{"deformable_conv_dmc"};
}

// Static class fields initialization
PluginFieldCollection DEFORMABLE_CONV_DMC_Creator::mFC{};
std::vector<PluginField> DEFORMABLE_CONV_DMC_Creator::mPluginAttributes;

REGISTER_TENSORRT_PLUGIN(DEFORMABLE_CONV_DMC_Creator);

//initialize funs
DEFORMABLE_CONV_DMC_Plugin::DEFORMABLE_CONV_DMC_Plugin(const std::string name,int p_kernel_h,int p_kernel_w,int p_stride_h,int p_stride_w,int p_pad_h,int p_pad_w,int p_dilation_h,int p_dilation_w)
  : mLayerName(name)
  , kernel_h(p_kernel_h)
  , kernel_w(p_kernel_w)
  , stride_h(p_stride_h)
  , stride_w(p_stride_w)
  , pad_h(p_pad_h)
  , pad_w(p_pad_w)
  , dilation_h(p_dilation_h)
  , dilation_w(p_dilation_w)
{
}

DEFORMABLE_CONV_DMC_Plugin::DEFORMABLE_CONV_DMC_Plugin(const std::string name,const void* data, size_t length)
  : mLayerName(name)
{
  // Deserialize in the same order as serialization
  const char *d = static_cast<const char *>(data);
  const char *a = d;
  readFromBuffer(d,kernel_h);
  readFromBuffer(d,kernel_w);
  readFromBuffer(d,stride_h);
  readFromBuffer(d,stride_w);
  readFromBuffer(d,pad_h);
  readFromBuffer(d,pad_w);
  readFromBuffer(d,dilation_h);
  readFromBuffer(d,dilation_w);
  readFromBuffer(d,channel);
  readFromBuffer(d,height);
  readFromBuffer(d,width);
  readFromBuffer(d,out_height);
  readFromBuffer(d,out_width);
  readFromBuffer(d,mDataType);

  assert(d == (a + length) && "length of data mismatch");
}

void DEFORMABLE_CONV_DMC_Plugin::serialize(void* buffer) const
{
  char *d = static_cast<char *>(buffer);
  const char *a = d;
  writeToBuffer(d,kernel_h);
  writeToBuffer(d,kernel_w);
  writeToBuffer(d,stride_h);
  writeToBuffer(d,stride_w);
  writeToBuffer(d,pad_h);
  writeToBuffer(d,pad_w);
  writeToBuffer(d,dilation_h);
  writeToBuffer(d,dilation_w);
  writeToBuffer(d,channel);
  writeToBuffer(d,height);
  writeToBuffer(d,width);
  writeToBuffer(d,out_height);
  writeToBuffer(d,out_width);
  writeToBuffer(d,mDataType);

  assert(d == a + getSerializationSize());
}

size_t DEFORMABLE_CONV_DMC_Plugin::getSerializationSize() const
{
  return sizeof(mDataType)+8*sizeof(int)+5*sizeof(int);
}

const char* DEFORMABLE_CONV_DMC_Plugin::getPluginType() const
{
  return DEFORMABLE_CONV_DMC_PLUGIN_NAME;
}

const char* DEFORMABLE_CONV_DMC_Plugin::getPluginVersion() const
{
  return DEFORMABLE_CONV_DMC_PLUGIN_VERSION;
}

int DEFORMABLE_CONV_DMC_Plugin::initialize()
{
  return 0;
}

void DEFORMABLE_CONV_DMC_Plugin::terminate() {}

void DEFORMABLE_CONV_DMC_Plugin::destroy()
{
  delete this;
}

//runtime functions
int DEFORMABLE_CONV_DMC_Plugin::getNbOutputs() const
{
  return 1;
}

Dims DEFORMABLE_CONV_DMC_Plugin::getOutputDimensions(int index, const Dims* inputs, int nbInputDims)
{
  // Validate input arguments, Please set output shapes manually
  assert(nbInputDims == 3);
  
  channel=inputs[0].d[0];
  height=inputs[0].d[1];
  width=inputs[0].d[2];
  out_height=1+(height+2*pad_h-(dilation_h*(kernel_h-1)+1))/stride_h;
  out_width=1+(width+2*pad_w-(dilation_w*(kernel_w-1)+1))/stride_w;
  if(index==0){
    return DimsCHW{channel*kernel_h*kernel_w,out_height,out_width};
  }
}

size_t DEFORMABLE_CONV_DMC_Plugin::getWorkspaceSize(int maxBatchSize) const
{
  return maxBatchSize*(0);
}

int DEFORMABLE_CONV_DMC_Plugin::enqueue(int batchSize, const void* const* inputs, void** outputs, void* workspace, cudaStream_t stream)
{
  if (mDataType == DataType::kFLOAT){
    deformable_conv_dmc(stream,
      reinterpret_cast<const float*>(inputs[0]),
      reinterpret_cast<const float*>(inputs[1]),
      reinterpret_cast<const float*>(inputs[2]),
      reinterpret_cast<float*>(outputs[0]),
      batchSize,
      channel,
      height,
      width,
      out_height,
      out_width,
      kernel_h,
      kernel_w,
      stride_h,
      stride_w,
      pad_h,
      pad_w,
      dilation_h,
      dilation_w);
  } else if (mDataType == DataType::kHALF){
    deformable_conv_dmc(stream,
      reinterpret_cast<const __half*>(inputs[0]),
      reinterpret_cast<const __half*>(inputs[1]),
      reinterpret_cast<const __half*>(inputs[2]),
      reinterpret_cast<__half*>(outputs[0]),
      batchSize,
      channel,
      height,
      width,
      out_height,
      out_width,
      kernel_h,
      kernel_w,
      stride_h,
      stride_w,
      pad_h,
      pad_w,
      dilation_h,
      dilation_w);
  }
  return 0;
}

//config functions
void DEFORMABLE_CONV_DMC_Plugin::configureWithFormat(const Dims* inputs, int nbInputs, const Dims* outputs, int nbOutputs, DataType type, PluginFormat format, int)
{
  // Validate input arguments
  assert(nbInputs == 3);
  assert(nbOutputs == 1);
  channel=inputs[0].d[0];
  height=inputs[0].d[1];
  width=inputs[0].d[2];
  out_height=1+(height+2*pad_h-(dilation_h*(kernel_h-1)+1))/stride_h;
  out_width=1+(width+2*pad_w-(dilation_w*(kernel_w-1)+1))/stride_w;
  mDataType = type;
}

bool DEFORMABLE_CONV_DMC_Plugin::supportsFormat(DataType type, PluginFormat format) const
{
  //fp16 for deformable conv results low accuracy
  return type == DataType::kFLOAT;
}


//describe functions
IPluginV2* DEFORMABLE_CONV_DMC_Plugin::clone() const
{
  return new DEFORMABLE_CONV_DMC_Plugin(mLayerName,kernel_h,kernel_w,stride_h,stride_w,pad_h,pad_w,dilation_h,dilation_w);
}

void DEFORMABLE_CONV_DMC_Plugin::setPluginNamespace(const char* libNamespace)
{
  mNamespace = libNamespace;
}

const char* DEFORMABLE_CONV_DMC_Plugin::getPluginNamespace() const
{
  return mNamespace.c_str();
}


//creator functions
DEFORMABLE_CONV_DMC_Creator::DEFORMABLE_CONV_DMC_Creator()
{
  mPluginAttributes.emplace_back(PluginField("kernel_h",nullptr,PluginFieldType::kINT32,1));
  mPluginAttributes.emplace_back(PluginField("kernel_w",nullptr,PluginFieldType::kINT32,1));
  mPluginAttributes.emplace_back(PluginField("stride_h",nullptr,PluginFieldType::kINT32,1));
  mPluginAttributes.emplace_back(PluginField("stride_w",nullptr,PluginFieldType::kINT32,1));
  mPluginAttributes.emplace_back(PluginField("pad_h",nullptr,PluginFieldType::kINT32,1));
  mPluginAttributes.emplace_back(PluginField("pad_w",nullptr,PluginFieldType::kINT32,1));
  mPluginAttributes.emplace_back(PluginField("dilation_h",nullptr,PluginFieldType::kINT32,1));
  mPluginAttributes.emplace_back(PluginField("dilation_w",nullptr,PluginFieldType::kINT32,1));
  // Fill PluginFieldCollection with PluginField arguments metadata
  mFC.nbFields = mPluginAttributes.size();
  mFC.fields = mPluginAttributes.data();
}

const char* DEFORMABLE_CONV_DMC_Creator::getPluginName() const
{
  return DEFORMABLE_CONV_DMC_PLUGIN_NAME;
}

const char* DEFORMABLE_CONV_DMC_Creator::getPluginVersion() const
{
  return DEFORMABLE_CONV_DMC_PLUGIN_VERSION;
}

const PluginFieldCollection* DEFORMABLE_CONV_DMC_Creator::getFieldNames()
{
  return &mFC;
}

IPluginV2* DEFORMABLE_CONV_DMC_Creator::createPlugin(const char* name, const PluginFieldCollection* fc)
{
  int kernel_h=0;
  int kernel_w=0;
  int stride_h=0;
  int stride_w=0;
  int pad_h=0;
  int pad_w=0;
  int dilation_h=0;
  int dilation_w=0;
  const PluginField* fields = fc->fields;

  // Parse fields from PluginFieldCollection
  assert(fc->nbFields == 8);
  for (int i = 0; i < fc->nbFields; i++){
    if (strcmp(fields[i].name, "kernel_h") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      kernel_h = *(static_cast<const int*>(fields[i].data));
    }else if (strcmp(fields[i].name, "kernel_w") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      kernel_w = *(static_cast<const int*>(fields[i].data));
    }else if (strcmp(fields[i].name, "stride_h") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      stride_h = *(static_cast<const int*>(fields[i].data));
    }else if (strcmp(fields[i].name, "stride_w") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      stride_w = *(static_cast<const int*>(fields[i].data));
    }else if (strcmp(fields[i].name, "pad_h") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      pad_h = *(static_cast<const int*>(fields[i].data));
    }else if (strcmp(fields[i].name, "pad_w") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      pad_w = *(static_cast<const int*>(fields[i].data));
    }else if (strcmp(fields[i].name, "dilation_h") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      dilation_h = *(static_cast<const int*>(fields[i].data));
    }else if (strcmp(fields[i].name, "dilation_w") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      dilation_w = *(static_cast<const int*>(fields[i].data));
    }
  }

  DEFORMABLE_CONV_DMC_Plugin* obj = new DEFORMABLE_CONV_DMC_Plugin(name,kernel_h,kernel_w,stride_h,stride_w,pad_h,pad_w,dilation_h,dilation_w);
  obj->setPluginNamespace(mNamespace.c_str());
  return obj;
}

IPluginV2* DEFORMABLE_CONV_DMC_Creator::deserializePlugin(const char* name, const void* serialData, size_t serialLength)
{
  DEFORMABLE_CONV_DMC_Plugin* obj = new DEFORMABLE_CONV_DMC_Plugin(name, serialData, serialLength);
  obj->setPluginNamespace(mNamespace.c_str());
  return obj;
}

void DEFORMABLE_CONV_DMC_Creator::setPluginNamespace(const char* libNamespace)
{
  mNamespace = libNamespace;
}

const char* DEFORMABLE_CONV_DMC_Creator::getPluginNamespace() const
{
  return mNamespace.c_str();
}

} // namespace ops_lib
} // namespace framework
} // namespace quake
