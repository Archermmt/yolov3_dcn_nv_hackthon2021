//
// Auto Generated by DLRouter on 2021-03-11 16:48:54.398678
// 

#include "trt_utils.h"
#include "yolo_box.h"
#include "kernel/gpu/yolo_box_kernel.h"

#include <cassert>

using namespace nvinfer1;

namespace quake {
namespace framework {
namespace ops_lib {

namespace {
  static const char* YOLO_BOX_PLUGIN_VERSION{"1"};
  static const char* YOLO_BOX_PLUGIN_NAME{"yolo_box"};
}

// Static class fields initialization
PluginFieldCollection YOLO_BOX_Creator::mFC{};
std::vector<PluginField> YOLO_BOX_Creator::mPluginAttributes;

REGISTER_TENSORRT_PLUGIN(YOLO_BOX_Creator);

//initialize funs
YOLO_BOX_Plugin::YOLO_BOX_Plugin(const std::string name,int p_class_num,float p_conf_thresh,float p_scale_x_y,bool p_clip_bbox)
  : mLayerName(name)
  , class_num(p_class_num)
  , conf_thresh(p_conf_thresh)
  , scale_x_y(p_scale_x_y)
  , clip_bbox(p_clip_bbox)
{
}

YOLO_BOX_Plugin::YOLO_BOX_Plugin(const std::string name,const void* data, size_t length)
  : mLayerName(name)
{
  // Deserialize in the same order as serialization
  const char *d = static_cast<const char *>(data);
  const char *a = d;
  readFromBuffer(d,class_num);
  readFromBuffer(d,conf_thresh);
  readFromBuffer(d,scale_x_y);
  readFromBuffer(d,clip_bbox);
  readFromBuffer(d,channel);
  readFromBuffer(d,height);
  readFromBuffer(d,width);
  readFromBuffer(d,anchors_num);
  readFromBuffer(d,boxes_num);
  readFromBuffer(d,mDataType);

  assert(d == (a + length) && "length of data mismatch");
}

void YOLO_BOX_Plugin::serialize(void* buffer) const
{
  char *d = static_cast<char *>(buffer);
  const char *a = d;
  writeToBuffer(d,class_num);
  writeToBuffer(d,conf_thresh);
  writeToBuffer(d,scale_x_y);
  writeToBuffer(d,clip_bbox);
  writeToBuffer(d,channel);
  writeToBuffer(d,height);
  writeToBuffer(d,width);
  writeToBuffer(d,anchors_num);
  writeToBuffer(d,boxes_num);
  writeToBuffer(d,mDataType);

  assert(d == a + getSerializationSize());
}

size_t YOLO_BOX_Plugin::getSerializationSize() const
{
  return sizeof(mDataType)+1*sizeof(int)+2*sizeof(float)+1*sizeof(bool)+5*sizeof(int);
}

const char* YOLO_BOX_Plugin::getPluginType() const
{
  return YOLO_BOX_PLUGIN_NAME;
}

const char* YOLO_BOX_Plugin::getPluginVersion() const
{
  return YOLO_BOX_PLUGIN_VERSION;
}

int YOLO_BOX_Plugin::initialize()
{
  return 0;
}

void YOLO_BOX_Plugin::terminate() {}

void YOLO_BOX_Plugin::destroy()
{
  delete this;
}

//runtime functions
int YOLO_BOX_Plugin::getNbOutputs() const
{
  return 2;
}

Dims YOLO_BOX_Plugin::getOutputDimensions(int index, const Dims* inputs, int nbInputDims)
{
  // Validate input arguments, Please set output shapes manually
  assert(nbInputDims == 3);
  
  channel=inputs[0].d[0];
  height=inputs[0].d[1];
  width=inputs[0].d[2];
  anchors_num=inputs[2].d[0];
  boxes_num=anchors_num*height*width;
  if(index==0){
    return Dims2{boxes_num,4};
  }else if(index==1){
    return Dims2{boxes_num,class_num};
  }
}

size_t YOLO_BOX_Plugin::getWorkspaceSize(int maxBatchSize) const
{
  return maxBatchSize*(boxes_num*4*sizeof(float));
}

int YOLO_BOX_Plugin::enqueue(int batchSize, const void* const* inputs, void** outputs, void* workspace, cudaStream_t stream)
{
  //get workspace and set to 0
  CHECK(cudaMemset(workspace,0,getWorkspaceSize(batchSize)));
  size_t offset=0;
  void* box_buf=workspace+offset;
  offset+=batchSize*boxes_num*4*sizeof(mDataType);

  if (mDataType == DataType::kFLOAT){
    yolo_box(stream,
      reinterpret_cast<const float*>(inputs[0]),
      reinterpret_cast<const float*>(inputs[1]),
      reinterpret_cast<const float*>(inputs[2]),
      reinterpret_cast<float*>(outputs[0]),
      reinterpret_cast<float*>(outputs[1]),
      reinterpret_cast<float*>(box_buf),
      batchSize,
      channel,
      height,
      width,
      anchors_num,
      boxes_num,
      class_num,
      conf_thresh,
      scale_x_y,
      clip_bbox);
  } else if (mDataType == DataType::kHALF){
    yolo_box(stream,
      reinterpret_cast<const __half*>(inputs[0]),
      reinterpret_cast<const __half*>(inputs[1]),
      reinterpret_cast<const __half*>(inputs[2]),
      reinterpret_cast<__half*>(outputs[0]),
      reinterpret_cast<__half*>(outputs[1]),
      reinterpret_cast<__half*>(box_buf),
      batchSize,
      channel,
      height,
      width,
      anchors_num,
      boxes_num,
      class_num,
      dlr_float2half(conf_thresh),
      dlr_float2half(scale_x_y),
      clip_bbox);
  }
  return 0;
}

//config functions
void YOLO_BOX_Plugin::configureWithFormat(const Dims* inputs, int nbInputs, const Dims* outputs, int nbOutputs, DataType type, PluginFormat format, int)
{
  // Validate input arguments
  assert(nbInputs == 3);
  assert(nbOutputs == 2);
  channel=inputs[0].d[0];
  height=inputs[0].d[1];
  width=inputs[0].d[2];
  anchors_num=inputs[2].d[0];
  boxes_num=anchors_num*height*width;
  mDataType = type;
}

bool YOLO_BOX_Plugin::supportsFormat(DataType type, PluginFormat format) const
{
  return true;
}


//describe functions
IPluginV2* YOLO_BOX_Plugin::clone() const
{
  return new YOLO_BOX_Plugin(mLayerName,class_num,conf_thresh,scale_x_y,clip_bbox);
}

void YOLO_BOX_Plugin::setPluginNamespace(const char* libNamespace)
{
  mNamespace = libNamespace;
}

const char* YOLO_BOX_Plugin::getPluginNamespace() const
{
  return mNamespace.c_str();
}


//creator functions
YOLO_BOX_Creator::YOLO_BOX_Creator()
{
  mPluginAttributes.emplace_back(PluginField("class_num",nullptr,PluginFieldType::kINT32,1));
  mPluginAttributes.emplace_back(PluginField("conf_thresh",nullptr,PluginFieldType::kFLOAT32,1));
  mPluginAttributes.emplace_back(PluginField("scale_x_y",nullptr,PluginFieldType::kFLOAT32,1));
  mPluginAttributes.emplace_back(PluginField("clip_bbox",nullptr,PluginFieldType::kINT32,1));
  // Fill PluginFieldCollection with PluginField arguments metadata
  mFC.nbFields = mPluginAttributes.size();
  mFC.fields = mPluginAttributes.data();
}

const char* YOLO_BOX_Creator::getPluginName() const
{
  return YOLO_BOX_PLUGIN_NAME;
}

const char* YOLO_BOX_Creator::getPluginVersion() const
{
  return YOLO_BOX_PLUGIN_VERSION;
}

const PluginFieldCollection* YOLO_BOX_Creator::getFieldNames()
{
  return &mFC;
}

IPluginV2* YOLO_BOX_Creator::createPlugin(const char* name, const PluginFieldCollection* fc)
{
  int class_num=0;
  float conf_thresh=0;
  float scale_x_y=0;
  bool clip_bbox=0;
  const PluginField* fields = fc->fields;

  // Parse fields from PluginFieldCollection
  assert(fc->nbFields == 4);
  for (int i = 0; i < fc->nbFields; i++){
    if (strcmp(fields[i].name, "class_num") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      class_num = *(static_cast<const int*>(fields[i].data));
    }else if (strcmp(fields[i].name, "conf_thresh") == 0) {
      assert(fields[i].type == PluginFieldType::kFLOAT32);
      conf_thresh = *(static_cast<const float*>(fields[i].data));
    }else if (strcmp(fields[i].name, "scale_x_y") == 0) {
      assert(fields[i].type == PluginFieldType::kFLOAT32);
      scale_x_y = *(static_cast<const float*>(fields[i].data));
    }else if (strcmp(fields[i].name, "clip_bbox") == 0) {
      assert(fields[i].type == PluginFieldType::kINT32);
      clip_bbox = *(static_cast<const bool*>(fields[i].data));
    }
  }

  YOLO_BOX_Plugin* obj = new YOLO_BOX_Plugin(name,class_num,conf_thresh,scale_x_y,clip_bbox);
  obj->setPluginNamespace(mNamespace.c_str());
  return obj;
}

IPluginV2* YOLO_BOX_Creator::deserializePlugin(const char* name, const void* serialData, size_t serialLength)
{
  YOLO_BOX_Plugin* obj = new YOLO_BOX_Plugin(name, serialData, serialLength);
  obj->setPluginNamespace(mNamespace.c_str());
  return obj;
}

void YOLO_BOX_Creator::setPluginNamespace(const char* libNamespace)
{
  mNamespace = libNamespace;
}

const char* YOLO_BOX_Creator::getPluginNamespace() const
{
  return mNamespace.c_str();
}

} // namespace ops_lib
} // namespace framework
} // namespace quake
